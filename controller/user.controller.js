import createError from 'http-errors';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import { User } from '../models/user.models.js';
import {
  sendEmailVerification,
  sendPasswordResetMail,
} from '../utils/sendMail.js';

const registerUser = async (req, res, next) => {
  const { email, username, password } = req.body;

  try {
    const userExists = await User.findOne({
      $or: [{ username }, { email }],
    });

    if (userExists) {
      throw createError.Conflict('User already exists');
    }

    const user = await User.create({
      email,
      password,
      username,
      isEmailVerified: false,
    });

    /**
     * unHashedToken: unHashed token is something we will send to the user's mail
     * hashedToken: we will keep record of hashedToken to validate the unHashedToken in verify email controller
     * tokenExpiry: Expiry to be checked before validating the incoming token
     */
    const { unHashedToken, hashedToken, tokenExpiry } =
      user.generateTemporaryToken();

    user.emailVerificationToken = hashedToken;
    user.emailVerificationExpiry = tokenExpiry;
    await user.save({ validateBeforeSave: false });

    await sendEmailVerification(email, unHashedToken);
    res.status(201).send({
      message:
        'User registered successfully & verification email has been sent',
    });
  } catch (error) {
    console.error(error);
    next(error);
  }
};

const verifyEmail = async (req, res, next) => {
  const { verificationToken } = req.params;

  if (!verificationToken) {
    throw createError.BadRequest('Missing email verification token');
  }
  try {
    let hashedToken = crypto
      .createHash('sha256')
      .update(verificationToken)
      .digest('hex');
    // While registering the user, same time when we are sending the verification mail
    // we have saved a hashed value of the original email verification token in the db
    // We will try to find user with the hashed token generated by received token
    // If we find the user another check is if token expiry of that token is greater than current time if not that means it is expired
    const user = await User.findOne({
      emailVerificationToken: hashedToken,
      emailVerificationExpiry: { $gt: Date.now() },
    });

    if (!user) {
      throw createError(489, 'Token is invalid or expired');
    }

    // If we found the user that means the token is valid
    // Now we can remove the associated email token and expiry date as we no  longer need them
    user.emailVerificationToken = undefined;
    user.emailVerificationExpiry = undefined;

    // // Tun the email verified flag to `true`
    user.isEmailVerified = true;

    await user.save({ validateBeforeSave: false });

    return res.status(200).send({ message: 'Email is verified!' });
  } catch (error) {
    console.error(error);
    next(error);
  }
};

const generateAccessAndRefreshTokens = async (userId) => {
  try {
    const user = await User.findById(userId);

    const accessToken = user.generateAccessToken();
    const refreshToken = user.generateRefreshToken();

    // attach refresh token to the user document to avoid refreshing the access token with multiple refresh tokens
    user.refreshToken = refreshToken;

    await user.save({ validateBeforeSave: false });
    return { accessToken, refreshToken };
  } catch (error) {
    console.error(error);
    throw createError.InternalServerError('Error generating access token');
  }
};

const loginUser = async (req, res, next) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) throw createError.NotFound('User not registered');

    // Compare the incoming password with hashed password
    const isPasswordValid = await user.isPasswordCorrect(password);
    if (!isPasswordValid)
      throw new createError.Unauthorized('Invalid credentials');

    const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(
      user._id
    );

    const options = {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
    };
    return res
      .status(200)
      .cookie('accessToken', accessToken, options)
      .cookie('refreshToken', refreshToken, options)
      .send({ accessToken: accessToken, refreshToken: refreshToken });
  } catch (error) {
    console.error(error);
    next(error);
  }
};

const refreshAccessToken = async (req, res, next) => {
  try {
    const incomingRefreshToken =
      req.cookies.refreshToken || req.body.refreshToken;

    if (!incomingRefreshToken)
      throw createError.Unauthorized('Unauthorized request');

    const decodedToken = jwt.verify(
      incomingRefreshToken,
      process.env.REFRESH_TOKEN_SECRET
    );

    const user = await User.findById(decodedToken?._id);
    if (!user) throw createError.Unauthorized('Invalid refresh token');

    // check if incoming refresh token is same as the refresh token attached in the user document
    // This shows that the refresh token is used or not
    // Once it is used, we are replacing it with new refresh token below
    if (incomingRefreshToken !== user?.refreshToken) {
      // If token is valid but is used already
      throw createError.Unauthorized('Refresh Token expired');
    }

    const options = {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
    };

    const { accessToken, refreshToken: newRefreshToken } =
      await generateAccessAndRefreshTokens(user._id);
    return res
      .status(200)
      .cookie('accessToken', accessToken, options)
      .cookie('refreshToken', newRefreshToken, options)
      .send({ accessToken, refreshToken: newRefreshToken });
  } catch (error) {
    console.error('Invalid refresh Token', error);
    next(error);
  }
};

const forgotPasswordRequest = async (req, res, next) => {
  const { email } = req.body;
  try {
    // Get email from the client and check if user exists
    const user = await User.findOne({ email });

    if (!user) throw createError.NotFound('User not found');

    // Generate a temporary token
    const { unHashedToken, hashedToken, tokenExpiry } =
      user.generateTemporaryToken();
    // save the hashed version a of the token and expiry in the DB
    user.forgotPasswordToken = hashedToken;
    user.forgotPasswordExpiry = tokenExpiry;
    await user.save({ validateBeforeSave: false });

    await sendPasswordResetMail(email, unHashedToken);

    res.status(200).send({
      message:
        'An email with link to reset password has been sent to your email address.',
    });
  } catch (error) {
    console.error('Invalid email', error);
    next(error);
  }
};

const resetForgottenPassword = async (req, res, next) => {
  const { resetToken } = req.params;
  const { password } = req.body;

  try {
    // Create a hash of the incoming reset token
    let hashedToken = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');

    // See if user with hash similar to resetToken exists
    // If yes then check if token expiry is greater than current date
    const user = await User.findOne({
      forgotPasswordToken: hashedToken,
      forgotPasswordExpiry: { $gt: Date.now() },
    });

    // If either of the one is false that means the token is invalid or expired
    if (!user) {
      throw createError(489, 'Token is invalid or expired');
    }

    // if everything is ok and token id valid
    // reset the forgot password token and expiry
    user.forgotPasswordToken = undefined;
    user.forgotPasswordExpiry = undefined;

    // Set the provided password as the new password
    user.password = password;
    await user.save({ validateBeforeSave: false });
    return res.status(200).send({ message: 'Password updated successfully!' });
  } catch (error) {
    console.error(error);
    next(error);
  }
};

export {
  registerUser,
  loginUser,
  verifyEmail,
  refreshAccessToken,
  forgotPasswordRequest,
  resetForgottenPassword,
};
